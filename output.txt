Введено сообщение:PROGRAMMING!!!
Запустим алгоритм , для первого считанного символа: P
Главный корень на текущем шаге - элемент с кодом/весом: (/0)
Создаем правое поддерево со значением: P с кодом 1 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом () и код первого вхождения символа (01101)
Кодовая строка теперь выглядит так: 01101
Создаем левое поддерево с кодом 0
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
               (1/P)
          (1)
               (0)
Запустим алгоритм , для считанного символа: R Проверим был ли данный символ уже считан и добавлен в дерево.
 иR
PиR
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (0/0)
Создаем правое поддерево со значением: R с кодом 01 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (0) и код первого вхождения символа (01111)
Кодовая строка теперь выглядит так: 01101001111
Создаем левое поддерево с кодом 00
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
               (1/P)
          (2)
                    (1/R)
               (1)
                    (0)
Запустим алгоритм , для считанного символа: O Проверим был ли данный символ уже считан и добавлен в дерево.
 иO
PиO
 иO
RиO
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (00/0)
Создаем правое поддерево со значением: O с кодом 001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (00) и код первого вхождения символа (01100)
Кодовая строка теперь выглядит так: 011010011110001100
Создаем левое поддерево с кодом 000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
               (1/P)
          (3)
                    (1/R)
               (2)
                         (1/O)
                    (1)
                         (0)
Найдены не упорядоченные элементы с (кодом/весом): (0/2) (1/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такого элемента нет
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (1/R)
               (2)
                         (1/O)
                    (1)
                         (0)
          (3)
               (1/P)
Запустим алгоритм , для считанного символа: G Проверим был ли данный символ уже считан и добавлен в дерево.
 иG
 иG
PиG
RиG
 иG
OиG
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (100/0)
Создаем правое поддерево со значением: G с кодом 1001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (100) и код первого вхождения символа (00100)
Кодовая строка теперь выглядит так: 01101001111000110010000100
Создаем левое поддерево с кодом 1000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                    (1/R)
               (3)
                         (1/O)
                    (2)
                              (1/G)
                         (1)
                              (0)
          (4)
               (1/P)
Найдены не упорядоченные элементы с (кодом/весом): (10/2) (11/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (0/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (1/R)
               (2)
                    (1/P)
          (4)
                    (1/O)
               (2)
                         (1/G)
                    (1)
                         (0)
Запустим алгоритм , для считанного символа: R Проверим был ли данный символ уже считан и добавлен в дерево.
 иR
 иR
 иR
RиR
Символ уже был считан!
Увеличим вес листа с данным символом и всех элементов над ним
Добавим в кодовую строку код этого листа: 11
Текущий вид кодовой строки: 0110100111100011001000010011
Проверим, упорядочено ли наше дерево
                    (2/R)
               (3)
                    (1/P)
          (5)
                    (1/O)
               (2)
                         (1/G)
                    (1)
                         (0)
Запустим алгоритм , для считанного символа: A Проверим был ли данный символ уже считан и добавлен в дерево.
 иA
 иA
 иA
RиA
PиA
OиA
 иA
GиA
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (000/0)
Создаем правое поддерево со значением: A с кодом 0001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (000) и код первого вхождения символа (000000)
Кодовая строка теперь выглядит так: 0110100111100011001000010011000000000
Создаем левое поддерево с кодом 0000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                    (2/R)
               (3)
                    (1/P)
          (6)
                    (1/O)
               (3)
                         (1/G)
                    (2)
                              (1/A)
                         (1)
                              (0)
Найдены не упорядоченные элементы с (кодом/весом): (00/2) (01/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (10/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (2/R)
               (4)
                         (1/G)
                    (2)
                              (1/A)
                         (1)
                              (0)
          (6)
                    (1/O)
               (2)
                    (1/P)
Запустим алгоритм , для считанного символа: M Проверим был ли данный символ уже считан и добавлен в дерево.
 иM
 иM
 иM
RиM
 иM
OиM
PиM
GиM
 иM
AиM
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (1000/0)
Создаем правое поддерево со значением: M с кодом 10001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (1000) и код первого вхождения символа (01010)
Кодовая строка теперь выглядит так: 0110100111100011001000010011000000000100001010
Создаем левое поддерево с кодом 10000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                    (2/R)
               (5)
                         (1/G)
                    (3)
                              (1/A)
                         (2)
                                   (1/M)
                              (1)
                                   (0)
          (7)
                    (1/O)
               (2)
                    (1/P)
Найдены не упорядоченные элементы с (кодом/весом): (100/2) (101/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (01/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (2/R)
               (4)
                         (1/G)
                    (2)
                         (1/O)
          (7)
                         (1/A)
                    (2)
                              (1/M)
                         (1)
                              (0)
               (3)
                    (1/P)
Запустим алгоритм , для считанного символа: M Проверим был ли данный символ уже считан и добавлен в дерево.
 иM
 иM
 иM
RиM
 иM
 иM
PиM
GиM
OиM
AиM
 иM
MиM
Символ уже был считан!
Увеличим вес листа с данным символом и всех элементов над ним
Добавим в кодовую строку код этого листа: 0101
Текущий вид кодовой строки: 01101001111000110010000100110000000001000010100101
Проверим, упорядочено ли наше дерево
                    (2/R)
               (4)
                         (1/G)
                    (2)
                         (1/O)
          (8)
                         (1/A)
                    (3)
                              (2/M)
                         (2)
                              (0)
               (4)
                    (1/P)
Найдены не упорядоченные элементы с (кодом/весом): (010/2) (011/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (00/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (2/R)
               (4)
                         (1/G)
                    (2)
                         (1/O)
          (8)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                         (2/M)
                    (2)
                         (0)
Найдены не упорядоченные элементы с (кодом/весом): (001/2) (010/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (101/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (2/R)
               (5)
                         (2/M)
                    (3)
                         (1/O)
          (8)
                         (1/A)
                    (2)
                         (1/P)
               (3)
                         (1/G)
                    (1)
                         (0)
Найдены не упорядоченные элементы с (кодом/весом): (101/2) (00/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такого элемента нет
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                    (2/R)
               (4)
                              (1/G)
                         (1)
                              (0)
                    (2)
                         (1/O)
          (8)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Запустим алгоритм , для считанного символа: I Проверим был ли данный символ уже считан и добавлен в дерево.
 иI
 иI
 иI
RиI
 иI
 иI
MиI
 иI
OиI
AиI
PиI
GиI
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (1010/0)
Создаем правое поддерево со значением: I с кодом 10101 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (1010) и код первого вхождения символа (00110)
Кодовая строка теперь выглядит так: 01101001111000110010000100110000000001000010100101101000110
Создаем левое поддерево с кодом 10100
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                    (2/R)
               (5)
                              (1/G)
                         (2)
                                   (1/I)
                              (1)
                                   (0)
                    (3)
                         (1/O)
          (9)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (10/3) (11/2)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такого элемента нет
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (1/G)
                         (2)
                                   (1/I)
                              (1)
                                   (0)
                    (3)
                         (1/O)
               (5)
                    (2/R)
          (9)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Запустим алгоритм , для считанного символа: N Проверим был ли данный символ уже считан и добавлен в дерево.
 иN
 иN
 иN
 иN
RиN
 иN
MиN
 иN
OиN
AиN
PиN
GиN
 иN
IиN
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (11100/0)
Создаем правое поддерево со значением: N с кодом 111001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (11100) и код первого вхождения символа (01011)
Кодовая строка теперь выглядит так: 011010011110001100100001001100000000010000101001011010001101110001011
Создаем левое поддерево с кодом 111000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                              (1/G)
                         (3)
                                   (1/I)
                              (2)
                                        (1/N)
                                   (1)
                                        (0)
                    (4)
                         (1/O)
               (6)
                    (2/R)
          (10)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (1110/2) (1111/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (110/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (1/G)
                         (2)
                              (1/O)
                    (4)
                              (1/I)
                         (2)
                                   (1/N)
                              (1)
                                   (0)
               (6)
                    (2/R)
          (10)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Запустим алгоритм , для считанного символа: G Проверим был ли данный символ уже считан и добавлен в дерево.
 иG
 иG
 иG
 иG
RиG
 иG
MиG
 иG
 иG
AиG
PиG
GиG
Символ уже был считан!
Увеличим вес листа с данным символом и всех элементов над ним
Добавим в кодовую строку код этого листа: 1111
Текущий вид кодовой строки: 0110100111100011001000010011000000000100001010010110100011011100010111111
Проверим, упорядочено ли наше дерево
                              (2/G)
                         (3)
                              (1/O)
                    (5)
                              (1/I)
                         (2)
                                   (1/N)
                              (1)
                                   (0)
               (7)
                    (2/R)
          (11)
                         (1/A)
                    (2)
                         (1/P)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (1111/2) (010/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (011/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (1/A)
                         (2)
                              (1/O)
                    (4)
                              (1/I)
                         (2)
                                   (1/N)
                              (1)
                                   (0)
               (6)
                    (2/R)
          (11)
                         (2/G)
                    (3)
                         (1/P)
               (5)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (01/3) (10/2)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такого элемента нет
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (1/A)
                         (2)
                              (1/O)
                    (4)
                              (1/I)
                         (2)
                                   (1/N)
                              (1)
                                   (0)
               (7)
                         (2/G)
                    (3)
                         (1/P)
          (11)
                    (2/R)
               (4)
                    (2/M)
Запустим алгоритм , для считанного символа: ! Проверим был ли данный символ уже считан и добавлен в дерево.
 и!
 и!
 и!
 и!
 и!
Rи!
Mи!
 и!
 и!
Gи!
Pи!
Aи!
Oи!
Iи!
 и!
Nи!
Символ не был считан!
Главный корень на текущем шаге - элемент с кодом/весом: (11000/0)
Создаем правое поддерево со значением: ! с кодом 110001 весом 0
Добавим в кодовую строку код родителя от которого построен лист с новым символом (11000) и код первого вхождения символа (11010)
Кодовая строка теперь выглядит так: 01101001111000110010000100110000000001000010100101101000110111000101111111100011010
Создаем левое поддерево с кодом 110000
Левое поддерево выбирается новым корнем, от которого будут построены последующие деревья
Увеличим веса правого поддерева и всех элементов над ним
Проверим, упорядочено ли наше дерево
                              (1/A)
                         (2)
                              (1/O)
                    (5)
                              (1/I)
                         (3)
                                   (1/N)
                              (2)
                                        (1/!)
                                   (1)
                                        (0)
               (8)
                         (2/G)
                    (3)
                         (1/P)
          (12)
                    (2/R)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (1100/2) (1101/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (100/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (1/A)
                         (2)
                              (1/O)
                    (4)
                              (1/I)
                         (2)
                              (1/P)
               (8)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                                   (1/!)
                              (1)
                                   (0)
          (12)
                    (2/R)
               (4)
                    (2/M)
Запустим алгоритм , для считанного символа: ! Проверим был ли данный символ уже считан и добавлен в дерево.
 и!
 и!
 и!
 и!
 и!
Rи!
Mи!
 и!
 и!
Gи!
 и!
Aи!
Oи!
Iи!
Pи!
Nи!
 и!
!и!
Символ уже был считан!
Увеличим вес листа с данным символом и всех элементов над ним
Добавим в кодовую строку код этого листа: 10001
Текущий вид кодовой строки: 0110100111100011001000010011000000000100001010010110100011011100010111111110001101010001
Проверим, упорядочено ли наше дерево
                              (1/A)
                         (2)
                              (1/O)
                    (4)
                              (1/I)
                         (2)
                              (1/P)
               (9)
                         (2/G)
                    (5)
                              (1/N)
                         (3)
                                   (2/!)
                              (2)
                                   (0)
          (13)
                    (2/R)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (1000/2) (1001/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (1111/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                                   (2/!)
                              (2)
                                   (0)
                         (3)
                              (1/O)
                    (5)
                              (1/I)
                         (2)
                              (1/P)
               (9)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (13)
                    (2/R)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (11111/2) (1000/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (1110/1)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                                   (1/O)
                              (1)
                                   (0)
                         (3)
                              (2/!)
                    (5)
                              (1/I)
                         (2)
                              (1/P)
               (9)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (13)
                    (2/R)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (1110/2) (1111/1)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такого элемента нет
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                              (2/!)
                         (3)
                                   (1/O)
                              (1)
                                   (0)
                    (5)
                              (1/I)
                         (2)
                              (1/P)
               (9)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (13)
                    (2/R)
               (4)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (111/3) (00/2)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (01/2)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                         (2/R)
                    (4)
                              (1/I)
                         (2)
                              (1/P)
               (8)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (13)
                         (2/!)
                    (3)
                              (1/O)
                         (1)
                              (0)
               (5)
                    (2/M)
Запустим алгоритм , для считанного символа: ! Проверим был ли данный символ уже считан и добавлен в дерево.
 и!
 и!
 и!
 и!
 и!
 и!
Mи!
Rи!
 и!
Gи!
 и!
!и!
Символ уже был считан!
Увеличим вес листа с данным символом и всех элементов над ним
Добавим в кодовую строку код этого листа: 011
Текущий вид кодовой строки: 0110100111100011001000010011000000000100001010010110100011011100010111111110001101010001011
Проверим, упорядочено ли наше дерево
                         (2/R)
                    (4)
                              (1/I)
                         (2)
                              (1/P)
               (8)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (14)
                         (3/!)
                    (4)
                              (1/O)
                         (1)
                              (0)
               (6)
                    (2/M)
Найдены не упорядоченные элементы с (кодом/весом): (011/3) (100/2)
Проверим нет ли элемента с весом меньшим чем вес 1го элемента, и находяшегося дальше 2го
Такой элемент найден: (00/2)
Поменяем их местами
Воставновим верную кодировку, такую что у каждого правого поддерева код=код родителя+1, у левого код=код родителя+0
Скоректируем веса, так что вес каждого корня дерева будет равен, сумме весов их левого и правого под дерева
                         (2/R)
                    (4)
                              (1/I)
                         (2)
                              (1/P)
               (8)
                         (2/G)
                    (4)
                              (1/N)
                         (2)
                              (1/A)
          (14)
                         (2/M)
                    (3)
                              (1/O)
                         (1)
                              (0)
               (6)
                    (3/!)
Кодовое дерево создано!

Закодированное сообщение: 0110100111100011001000010011000000000100001010010110100011011100010111111110001101010001011
